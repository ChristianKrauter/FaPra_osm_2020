<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.71/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.71/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <script src="jquery-3.5.1.min.js"></script>
</head>
<body>
 <div id="cesiumContainer" class="fullSize"></div>
<script type="text/javascript">
  var data = {
    startLat: "",
    startLng: "",
    endLat: "",
    endLng: ""
  }

  var osm = new Cesium.OpenStreetMapImageryProvider({
      url : 'https://a.tile.openstreetmap.org/'
  });

  var viewer = new Cesium.Viewer("cesiumContainer", {
    selectionIndicator: false,
    infoBox: false,
    terrainProvider: Cesium.createWorldTerrain(),
  });

  if (!viewer.scene.pickPositionSupported) {
    window.alert("This browser does not support pickPosition.");
  }

  viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(
    Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK
    );

  function createPoint(worldPosition) {
    var point = viewer.entities.add({
      position: worldPosition,
      point: {
        color: Cesium.Color.WHITE,
        pixelSize: 5,
        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
      },
    });
    return point;
  }

  var drawingMode = "line";

  function drawShape(positionData) {
    var shape;
    if (drawingMode === "line") {
      shape = viewer.entities.add({
        polyline: {
          positions: positionData,
          clampToGround: true,
          width: 3,
        },
      });
    } else if (drawingMode === "polygon") {
      shape = viewer.entities.add({
        polygon: {
          hierarchy: positionData,
          material: new Cesium.ColorMaterialProperty(
            Cesium.Color.WHITE.withAlpha(0.7)
            ),
        },
      });
    }
    return shape;
  }
  function onLeftMouseClick (event) {
  // We use `viewer.scene.pickPosition` here instead of `viewer.camera.pickEllipsoid` so that
  // we get the correct point when mousing over terrain.
  var earthPosition = viewer.scene.pickPosition(event.position);

  // `earthPosition` will be undefined if our mouse is not over the globe.
  if (Cesium.defined(earthPosition)) {

    const cartographic = viewer.scene.globe.ellipsoid.cartesianToCartographic(earthPosition);
    const longitudeString = Cesium.Math.toDegrees(cartographic.longitude).toFixed(15);
    const latitudeString = Cesium.Math.toDegrees(cartographic.latitude).toFixed(15);
    if (data["startLat"] == "") {
            data["startLat"] = latitudeString
            data["startLng"] = longitudeString

            //popup.setLatLng(e.latlng).setContent("Start").openOn(map);

        } else {
            data["endLat"] = latitudeString
            data["endLng"] = longitudeString

            //popup.setLatLng(e.latlng).setContent("End").openOn(map);

            $.ajax({
                url: "/point",
                data: data
            }).done(function(data) {
                if (data == "false") {
                  b = Cesium.Billboard();
                   viewer.entities.add({
                     position: Cesium.Cartesian3.fromDegrees(earthPosition),
                     billboard: {
                     text: "test"
                 }
             });

                }
                //showRoute(JSON.parse(data))
                
                var coordinates = JSON.parse(data).features[0].geometry.coordinates;
                var cord1d = []
                coordinates.forEach(element => cord1d.push(element[0],element[1]))
                console.log(cord1d)
                viewer.entities.add({
                  name:"test",
                  polyline: {
                    positions: Cesium.Cartesian3.fromDegreesArray(cord1d),
                    width: 1,
                    material: Cesium.Color.DEEPSKYBLUE,
                  },
                })
                //var last = c.length - 1; 
                //if (crd[0][0] !== crd[last][0] || crd[0][1] !== crd[last][1]) {
                //    crd.push(crd[0]);
                //}
                //line.geometry.type = 'Polygon';
                //line.geometry.coordinates = [crd];
            });

            data = {
                startLat: "",
                startLng: "",
                endLat: "",
                endLng: ""
            }
        }
    if (activeShapePoints.length === 0) {
      floatingPoint = createPoint(earthPosition);
      //activeShapePoints.push(earthPosition);
      var dynamicPositions = new Cesium.CallbackProperty(function () {
    
        return activeShapePoints;
      }, false);
      activeShape = drawShape(dynamicPositions);
    }
    //activeShapePoints.push(earthPosition);
    createPoint(earthPosition);
  }
}

  var activeShapePoints = [];
  var activeShape;
  var floatingPoint;
  var handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
  handler.setInputAction(onLeftMouseClick, Cesium.ScreenSpaceEventType.LEFT_CLICK);

// Redraw the shape so it's not dynamic and remove the dynamic shape.
function terminateShape() {
  activeShapePoints.pop();
  drawShape(activeShapePoints);
  viewer.entities.remove(floatingPoint);
  viewer.entities.remove(activeShape);
  floatingPoint = undefined;
  activeShape = undefined;
  activeShapePoints = [];
}

var options = [
{
  text: "Draw Lines",
  onselect: function () {
    if (!Cesium.Entity.supportsPolylinesOnTerrain(viewer.scene)) {
      window.alert(
        "This browser does not support polylines on terrain."
        );
    }

    terminateShape();
    drawingMode = "line";
  },
},
{
  text: "Draw Polygons",
  onselect: function () {
    terminateShape();
    drawingMode = "polygon";
  },
},
];


// Zoom in to an area with mountains
viewer.camera.lookAt(
  //Cesium.Cartesian3.fromDegrees(-122.2058, 46.1955, 1000.0),
  //new Cesium.Cartesian3(5000.0, 5000.0, 5000.0)
  Cesium.Cartesian3.fromDegrees(0, 0, 0.0),
  new Cesium.Cartesian3(0.0,0.0, 42000000.0)
  );
viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
viewer.timeline.destroy()
viewer.sceneModePicker.destroy()
viewer.navigationHelpButton.destroy()
//viewer.baseLayerPicker.destroy()
viewer.homeButton.destroy()
viewer.geocoder.destroy()
viewer.animation.destroy()
</script>
<style type="text/css">
    .cesium-viewer-bottom{
      display: none!important
    }
  </style>
</body>
</html>